%%---------------------------------------------------------------------------%%
%% MTConcept.tex
%% Shawn Pautz
%% Time-stamp: <99/07/23 10:42:41 pautz>
%%---------------------------------------------------------------------------%%
%\documentclass[11pt]{rnote}
\documentclass[note]{newmemo}
\usepackage[centertags]{amsmath}
\usepackage{amssymb,amsthm,graphicx}
\usepackage[mathcal]{euscript}
\usepackage{tmadd}
\usepackage{tmath}
\usepackage{cite}
\usepackage{tabularx}
\usepackage{stl}
\usepackage{c++}

%%---------------------------------------------------------------------------%%
%% DEFINE SPECIFIC ENVIRONMENTS HERE
%%---------------------------------------------------------------------------%%
%\newcommand{\elfit}{\ensuremath{\operatorname{Im}(-1/\epsilon(\vq,\omega)}}
%\msection{}-->section commands
%\tradem{}  -->add TM subscript to entry
%\ucatm{}   -->add trademark footnote about entry

%%---------------------------------------------------------------------------%%
%% BEGIN DOCUMENT
%%---------------------------------------------------------------------------%%
\begin{document}

%%---------------------------------------------------------------------------%%
%% OPTIONS FOR NOTE
%%---------------------------------------------------------------------------%%

\toms{Distribution}
%\toms{Joe Sixpak/XTM, MS B226}
\refno{XTM-RN(U)99-006}
\subject{Specification of Solon Mesh Concepts}

%-------NO CHANGES
\groupname{X-TM:Transport Methods Group}
\groupmail{XTM, Mail Stop D409}
\groupphone{Phone: 505-667-7029 Fax: 505-665-4972}

\fromms{Shawn D. Pautz/XTM D409 \\ Randy M. Roberts}
\phone{(505)667--9138}
\originator{sdp}
\typist{sdp}
\date{\today}
%-------NO CHANGES

%-------OPTIONS
%\reference{NPB Star Reimbursable Project}
%\thru{P. D. Soran, XTM, MS B226}
%\enc{list}      
%\attachments{list}
%\cy{list}
%\encas
%\attachmentas
%\attachmentsas 
%-------OPTIONS

%%---------------------------------------------------------------------------%%
%% DISTRIBUTION LIST
%%---------------------------------------------------------------------------%%

\distribution {
  XTM MS D409:\\ 
  J.E. Morel, XTM MS D409\\ 
  G.L. Olson, XTM MS D409\\ 
  J.M. McGhee, XTM MS D409\\ 
  H.G. Hughes, XTM MS D409\\ 
  T. Adams, XTM MS D409\\ 
  M. Alme, XTM MS D409\\ 
  T.M. Evans, XTM MS D409\\ 
  M.G. Gray, XTM MS D409\\ 
  M.L. Hall, XTM MS D409\\ 
  S.D. Pautz, XTM MS D409\\ 
  R.M. Roberts, XTM MS D409\\ 
  S.A. Turner, XTM MS D409\\ 
  T.J. Urbatsch, XTM MS D409\\ 
  T.A. Wareing, XTM MS D409\\ 
  J.S. Warsa, XTM MS D409\\ 
  XDO MS B218:\\ 
}

%%---------------------------------------------------------------------------%%
%% BEGIN NOTE
%%---------------------------------------------------------------------------%%

\opening

\begin{abstract}

In this note we describe the \concept{Solon 3D Orthogonal Cartesian
  Mesh} concept, which defines the
requirements for a \C++ class that provides a variety of services for
an orthogonal 3D Cartesian mesh. This concept was originally defined
for use in the Solon radiation transport package, but is intended to
be used by other similar packages as well. The \concept{Solon 3D
  Orthogonal Cartesian Mesh} concept is 
defined in generic terms that correspond with those used in the
Standard Template Library; hence any class that conforms to the
\concept{Solon 3D Orthogonal Cartesian Mesh} requirements is a valid
model of this concept
and also may be used with numerous STL components. Since the
\concept{Solon 3D Orthogonal Cartesian Mesh} concept could prove
useful to other radiation transport
packages, classes that are models of it have been included in the
Draco component library.

\end{abstract}

\section{Introduction}

The recent development of the \C++ Standard Template Library
(STL)~\cite{ansi:cpp} has
provided \C++ developers with many useful and efficient classes and
algorithms to incorporate in their codes. Of arguably greater
importance, however, it has advanced the appreciation and use of
generic programming techniques. Generic programming offers the
possibility of true code reuse, one of the benefits sought by \C++
users but too often unrealized in the past.

During the design of the Solon radiation transport package the need
for a class to supply data and services related to the mesh was
appreciated. The initial development of this mesh class borrowed many
ideas from the STL; more recently it has been updated to reflect the
generic programming standards set forth in Ref.~\cite{au99}. In
keeping with the terminology introduced in Ref.~\cite{au99}, we have
defined the \concept{Solon 3D Orthogonal Cartesian Mesh} {\it
  concept}; a concept is the set of
requirements and constraints imposed on a class or set of classes. Any
class meeting the requirements of a given concept is said to be a {\it
  model} of that concept; in particular, any class adhering to the
\concept{Solon 3D Orthogonal Cartesian Mesh} requirements is a model
of this concept. Since the mesh
requirements of Solon are incorporated in the \concept{Solon 3D
  Orthogonal Cartesian Mesh} concept,
any model of this concept may be used in Solon with minimal
integration effort, despite potentially radically different
implementation details~\cite{ro99}.

The \concept{Solon 3D Orthogonal Cartesian Mesh} concept (and the
classes that are models of it) is a
part of the larger Draco effort to define and implement \C++ components 
useful for the development of a wide variety of radiation transport
packages. As packages are developed, and as their needs are met by
defining appropriate concepts and implementing models of those
concepts, it is hoped that each successive package will need to define 
and implement fewer new concepts and instead can reuse previously
designed and tested Draco components.

The rest of this document is organized as follows. In
Section~\ref{sec:general description} we give a general description of 
the mesh concepts that we define in detail later. In
Section~\ref{sec:basic concepts} we define the low level concepts that 
are used by the mesh concepts. In Section~\ref{sec:mesh concepts} we
define more complicated concepts such as fields and the mesh concepts
themselves.


\section{General Description of the \concept{Solon 3D Orthogonal
    Cartesian Mesh} Concept}
\label{sec:general description}

The \concept{Solon 3D Orthogonal Cartesian Mesh} concept is defined in 
detail in Section~\ref{sec:solon 3d orth cart mesh}, but we wish to
give a basic overview of this
concept here. The \concept{Solon 3D Orthogonal Cartesian Mesh} concept
is actually a specialization, or {\it refinement}~\cite{au99}, of the
\concept{Solon 3D Mesh} concept, which is defined in
Section~\ref{sec:solon 3d mesh}. The
\concept{Solon 3D Orthogonal Cartesian Mesh} concept is used for the
special case of an orthogonal hexahedral mesh; it has a few member
functions that have meaning only in this case.

The \concept{Solon 3D Mesh} concept contains most of the services
needed by the Solon package. It contains several nested classes that
represent field types, such as cell centered fields and vertex
centered fields. These fields are refinements of the \concept{Solon
  Mesh Field} concept, defined in Section~\ref{sec:solon mesh
  field}. The \concept{Solon 3D
  Mesh} concept has a variety of scatter and gather member functions
between different pairs of fields. These scatter and gather operations 
are specialized according to the low level mathematical operations
they perform by means of one of several tag classes (in some
implementations these ``tag'' classes may have more functionality than 
being mere tags). These tag classes are refinements of the
\concept{Scatter/Gather Tag} concept, defined in
Section~\ref{sec:scatter gather tag}. The
\concept{Solon 3D Mesh} concept also contains numerous global
reduction functions for all of the fields and it supplies other mesh
related services such as the calculation of cell volumes and
coordinates.

It is assumed that an implementation of the \concept{Solon 3D
  Orthogonal Cartesian Mesh} concept will potentially make use of
parallelism. Solon is designed in such a way that all parallel issues
related to the mesh are handled by the class that models the
\concept{Solon 3D Orthogonal Cartesian Mesh} concept. For example,
rather than making Solon aware of whether the data associated with two 
neighboring cells is on the same or different processes, or whether
the parallelism/communication is based on message passing or threads,
these issues instead are the responsibility of the scatter/gather
operations that may involve them.

We note that no assumptions are made regarding the implementation of
the \concept{Solon 3D Orthogonal Cartesian Mesh} concept. Any
implementation that conforms to the public interface specified in the
following sections and performs the defined operations is valid; this
is an integral goal of the generic programming approach. Hence a
variety of implementations of different complexities and with
different performance characteristics may be used with Solon without
requiring any code changes in Solon.

\section{Basic Concepts}
\label{sec:basic concepts}

Besides the \concept{Solon 3D Orthogonal Cartesian Mesh} concept
itself, there are several associated concepts that together are used
to define the \concept{Solon 3D Orthogonal Cartesian Mesh}
concept. Some of the lowest level concepts are already defined in
Ref.~\cite{au99} and will not be restated here. In this section we
define some slightly higher level, although still basic, concepts. In
Section~\ref{sec:mesh concepts} we will define the higher level
concepts that are specifically associated with a mesh.

\subsection{Binary Op}

A \concept{Binary Op} is a \concept{Binary Function} that may alter
the value of its first argument but otherwise does not return a
value.

\subsubsection{Refinement of}
\concept{Binary Function} (~\cite{au99}, page 112).

\subsubsection{Associated Types}

No additional types beyond those defined in \concept{Binary Function}, 
but the requirements are strengthened. The first argument type must be 
mutable and the result type must be \comp{void}.

\subsubsection{Models}

Any function that takes two arguments, the first of which is mutable,
and has a return type of \comp{void} behaves as a \concept{Binary
  Op}. For example, a function pointer of type \comp{void (*)(double
  \&, const double \&)} is a model of \concept{Binary Op}.

\bigskip

\subsection{Default Constructible Binary Op}

A \concept{Default Constructible Binary Op} is a \concept{Binary Op}
that has a default constructor.

\subsubsection{Refinement of}
\concept{Default Constructible} (~\cite{au99}, page 84), \concept{Binary
  Op}.

\subsubsection{Models}

All of the \comp{Mesh\cu XYZ} \concept{Binary Op}'s in Draco are
models of \concept{Default Constructible Binary Op}.

\newpage

\subsection{Assign Op}

An \concept{Assign Op} is a \concept{Default Constructible Binary Op}
that does assignment operations.

\subsubsection{Refinement of}
\concept{Default Constructible Binary Op}.

\subsubsection{Notation}
\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.4\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
  \comp{Op} & A type that is a model of \concept{Assign Op}. \\
  \comp{X} & \comp{Op}'s first argument type. \\
  \comp{Y} & \comp{Op}'s second argument type. \\
  \comp{op} & Object of type \comp{Op}. \\
  \comp{x} & Object of type \comp{X}. \\
  \comp{y} & Object of type \comp{Y}. \\
\end{tabularx}

\subsubsection{Valid Expressions}

\begin{exprlist}
  \expritem{Function call}{op(x,y)}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Type requirements: & \comp{x} must be mutable. \\
                        & \comp{operator=} must be defined between
     objects of type \comp{X} and objects of type \comp{Y}. \\
     Return type: & \comp{void}. \\
     Precondition: & The ordered pair \comp{(x,y)} is in the domain of 
     \comp{operator=}. \\
     Semantics: & Equivalent to \comp{operator=} applied between the
     two arguments. \\
     Postcondition: & The value of the first argument is in the range
     of \comp{operator=}. \\
     \end{tabularx}}
\end{exprlist}

\subsubsection{Models}

The \comp{Mesh\cu XYZ::OpAssign} class in Draco is a model of
\concept{Assign Op}.

\newpage

\subsection{Add Assign Op}

An \concept{Add Assign Op} is a \concept{Default Constructible Binary
  Op} that does assignment with addition operations.

\subsubsection{Refinement of}
\concept{Default Constructible Binary Op}.

\subsubsection{Notation}
\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.4\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
  \comp{Op} & A type that is a model of \concept{Add Assign Op}. \\
  \comp{X} & \comp{Op}'s first argument type. \\
  \comp{Y} & \comp{Op}'s second argument type. \\
  \comp{op} & Object of type \comp{Op}. \\
  \comp{x} & Object of type \comp{X}. \\
  \comp{y} & Object of type \comp{Y}. \\
\end{tabularx}

\subsubsection{Valid Expressions}

\begin{exprlist}
  \expritem{Function call}{op(x,y)}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Type requirements: & \comp{x} must be mutable. \\
                        & \comp{operator+=} must be defined between
     objects of type \comp{X} and objects of type \comp{Y}. \\
     Return type: & \comp{void}. \\
     Precondition: & The ordered pair \comp{(x,y)} is in the domain of 
     \comp{operator+=}. \\
     Semantics: & Equivalent to \comp{operator+=} applied between the
     two arguments. \\
     Postcondition: & The value of the first argument is in the range
     of \comp{operator+=}. \\
     \end{tabularx}}
\end{exprlist}

\subsubsection{Models}

The \comp{Mesh\cu XYZ::OpAddAssign} class in Draco is a model of
\concept{Add Assign Op}.

\newpage

\subsection{Sub Assign Op}

A \concept{Sub Assign Op} is a \concept{Default Constructible Binary
  Op} that does assignment with subtraction operations.

\subsubsection{Refinement of}
\concept{Default Constructible Binary Op}.

\subsubsection{Notation}
\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.4\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
  \comp{Op} & A type that is a model of \concept{Sub Assign Op}. \\
  \comp{X} & \comp{Op}'s first argument type. \\
  \comp{Y} & \comp{Op}'s second argument type. \\
  \comp{op} & Object of type \comp{Op}. \\
  \comp{x} & Object of type \comp{X}. \\
  \comp{y} & Object of type \comp{Y}. \\
\end{tabularx}

\subsubsection{Valid Expressions}

\begin{exprlist}
  \expritem{Function call}{op(x,y)}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Type requirements: & \comp{x} must be mutable. \\
                        & \comp{operator-=} must be defined between
     objects of type \comp{X} and objects of type \comp{Y}. \\
     Return type: & \comp{void}. \\
     Precondition: & The ordered pair \comp{(x,y)} is in the domain of 
     \comp{operator-=}. \\
     Semantics: & Equivalent to \comp{operator-=} applied between the
     two arguments. \\
     Postcondition: & The value of the first argument is in the range
     of \comp{operator-=}. \\
     \end{tabularx}}
\end{exprlist}

\subsubsection{Models}

The \comp{Mesh\cu XYZ::OpSubAssign} class in Draco is a model of
\concept{Sub Assign Op}.

\newpage

\subsection{Mult Assign Op}

A \concept{Mult Assign Op} is a \concept{Default Constructible Binary
  Op} that does assignment with multiplication operations.

\subsubsection{Refinement of}
\concept{Default Constructible Binary Op}.

\subsubsection{Notation}
\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.4\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
  \comp{Op} & A type that is a model of \concept{Mult Assign Op}. \\
  \comp{X} & \comp{Op}'s first argument type. \\
  \comp{Y} & \comp{Op}'s second argument type. \\
  \comp{op} & Object of type \comp{Op}. \\
  \comp{x} & Object of type \comp{X}. \\
  \comp{y} & Object of type \comp{Y}. \\
\end{tabularx}

\subsubsection{Valid Expressions}

\begin{exprlist}
  \expritem{Function call}{op(x,y)}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Type requirements: & \comp{x} must be mutable. \\
                        & \comp{operator*=} must be defined between
     objects of type \comp{X} and objects of type \comp{Y}. \\
     Return type: & \comp{void}. \\
     Precondition: & The ordered pair \comp{(x,y)} is in the domain of 
     \comp{operator*=}. \\
     Semantics: & Equivalent to \comp{operator*=} applied between the
     two arguments. \\
     Postcondition: & The value of the first argument is in the range
     of \comp{operator*=}. \\
     \end{tabularx}}
\end{exprlist}

\subsubsection{Models}

The \comp{Mesh\cu XYZ::OpMultAssign} class in Draco is a model of
\concept{Mult Assign Op}.

\newpage

\subsection{Min Assign Op}

A \concept{Min Assign Op} is a \concept{Default Constructible Binary
  Op} that does assignment with minimum operations.

\subsubsection{Refinement of}
\concept{Default Constructible Binary Op}.

\subsubsection{Notation}
\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.4\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
  \comp{Op} & A type that is a model of \concept{Min Assign Op}. \\
  \comp{X} & \comp{Op}'s first argument type. \\
  \comp{Y} & \comp{Op}'s second argument type. \\
  \comp{op} & Object of type \comp{Op}. \\
  \comp{x} & Object of type \comp{X}. \\
  \comp{y} & Object of type \comp{Y}. \\
\end{tabularx}

\subsubsection{Valid Expressions}

\begin{exprlist}
  \expritem{Function call}{op(x,y)}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Type requirements: & \comp{x} must be mutable. \\
                        & \comp{min()} must be defined between
     objects of type \comp{X} and objects of type \comp{Y}. \\
     Return type: & \comp{void}. \\
     Precondition: & The ordered pair \comp{(x,y)} is in the domain of 
     \comp{min()}. \\
     Semantics: & Equivalent to \comp{min()} applied between the
     two arguments. \\
     Postcondition: & The value of the first argument is in the range
     of \comp{min()}. \\
     \end{tabularx}}
\end{exprlist}

\subsubsection{Models}

The \comp{Mesh\cu XYZ::OpMinAssign} class in Draco is a model of
\concept{Min Assign Op}.

\newpage

\subsection{Max Assign Op}

A \concept{Max Assign Op} is a \concept{Default Constructible Binary
  Op} that does assignment with maximum operations.

\subsubsection{Refinement of}
\concept{Default Constructible Binary Op}.

\subsubsection{Notation}
\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.4\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
  \comp{Op} & A type that is a model of \concept{Max Assign Op}. \\
  \comp{X} & \comp{Op}'s first argument type. \\
  \comp{Y} & \comp{Op}'s second argument type. \\
  \comp{op} & Object of type \comp{Op}. \\
  \comp{x} & Object of type \comp{X}. \\
  \comp{y} & Object of type \comp{Y}. \\
\end{tabularx}

\subsubsection{Valid Expressions}

\begin{exprlist}
  \expritem{Function call}{op(x,y)}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Type requirements: & \comp{x} must be mutable. \\
                        & \comp{max()} must be defined between
     objects of type \comp{X} and objects of type \comp{Y}. \\
     Return type: & \comp{void}. \\
     Precondition: & The ordered pair \comp{(x,y)} is in the domain of 
     \comp{max()}. \\
     Semantics: & Equivalent to \comp{max()} applied between the
     two arguments. \\
     Postcondition: & The value of the first argument is in the range
     of \comp{max()}. \\
     \end{tabularx}}
\end{exprlist}

\subsubsection{Models}

The \comp{Mesh\cu XYZ::OpMaxAssign} class in Draco is a model of
\concept{Max Assign Op}.

\newpage

\subsection{Scatter/Gather Tag}
\label{sec:scatter gather tag}

A \concept{Scatter/Gather Tag} is a concept that is used in
association with the scatter and gather operations of \concept{Solon
  3D Mesh}. It is at least \concept{Default Constructible}, but in
some implementations it may also be a \concept{Binary Op}.

\subsubsection{Refinement of}
\concept{Default Constructible} (~\cite{au99}, page 84).

\subsubsection{Associated Types}

Each model of \concept{Scatter/Gather Tag} has a model of
\concept{Binary Op} associated with it (in some implementations these
will be the same type). This associated type may not actually be
defined, but the semantics of its underlying operation must be.

\subsubsection{Models}

All of the \comp{Mesh\cu XYZ} \concept{Binary Op}'s in Draco are
models of \concept{Scatter/Gather Tag}.

\bigskip

\subsection{Assign Tag}

An \concept{Assign Tag} is a \concept{Scatter/Gather Tag} that causes
the \concept{Solon 3D Mesh} scatter/gather operations to use the
semantics of \concept{Assign Op}.

\subsubsection{Refinement of}
\concept{Scatter/Gather Tag}.

\subsubsection{Associated Types}

A model of \concept{Assign Op}. Depending on implementation, this
associated type may not be defined, but the semantics of its
underlying operation must be.

\subsubsection{Models}

The \comp{Mesh\cu XYZ::OpAssign} class in Draco is a model of
\concept{Assign Tag}.

\subsection{Add Assign Tag}

An \concept{Add Assign Tag} is a \concept{Scatter/Gather Tag} that
causes the \concept{Solon 3D Mesh} scatter/gather operations to use
the semantics of \concept{Add Assign Op}.

\subsubsection{Refinement of}
\concept{Scatter/Gather Tag}.

\subsubsection{Associated Types}

A model of \concept{Add Assign Op}. Depending on implementation, this
associated type may not be defined, but the semantics of its
underlying operation must be.

\subsubsection{Models}

The \comp{Mesh\cu XYZ::OpAddAssign} class in Draco is a model of
\concept{Add Assign Tag}.

\bigskip

\subsection{Sub Assign Tag}

A \concept{Sub Assign Tag} is a \concept{Scatter/Gather Tag} that
causes the \concept{Solon 3D Mesh} scatter/gather operations to use
the semantics of \concept{Sub Assign Op}.

\subsubsection{Refinement of}
\concept{Scatter/Gather Tag}.

\subsubsection{Associated Types}

A model of \concept{Sub Assign Op}. Depending on implementation, this
associated type may not be defined, but the semantics of its
underlying operation must be.

\subsubsection{Models}

The \comp{Mesh\cu XYZ::OpSubAssign} class in Draco is a model of
\concept{Sub Assign Tag}.

\newpage

\subsection{Mult Assign Tag}

A \concept{Mult Assign Tag} is a \concept{Scatter/Gather Tag} that
causes the \concept{Solon 3D Mesh} scatter/gather operations to use
the semantics of \concept{Mult Assign Op}.

\subsubsection{Refinement of}
\concept{Scatter/Gather Tag}.

\subsubsection{Associated Types}

A model of \concept{Mult Assign Op}. Depending on implementation, this
associated type may not be defined, but the semantics of its
underlying operation must be.

\subsubsection{Models}

The \comp{Mesh\cu XYZ::OpMultAssign} class in Draco is a model of
\concept{Mult Assign Tag}.

\bigskip

\subsection{Min Assign Tag}

A \concept{Min Assign Tag} is a \concept{Scatter/Gather Tag} that
causes the \concept{Solon 3D Mesh} scatter/gather operations to use
the semantics of \concept{Min Assign Op}.

\subsubsection{Refinement of}
\concept{Scatter/Gather Tag}.

\subsubsection{Associated Types}

A model of \concept{Min Assign Op}. Depending on implementation, this
associated type may not be defined, but the semantics of its
underlying operation must be.

\subsubsection{Models}

The \comp{Mesh\cu XYZ::OpMinAssign} class in Draco is a model of
\concept{Min Assign Tag}.

\newpage

\subsection{Max Assign Tag}

A \concept{Max Assign Tag} is a \concept{Scatter/Gather Tag} that
causes the \concept{Solon 3D Mesh} scatter/gather operations to use
the semantics of \concept{Max Assign Op}.

\subsubsection{Refinement of}
\concept{Scatter/Gather Tag}.

\subsubsection{Associated Types}

A model of \concept{Max Assign Op}. Depending on implementation, this
associated type may not be defined, but the semantics of its
underlying operation must be.

\subsubsection{Models}

The \comp{Mesh\cu XYZ::OpMaxAssign} class in Draco is a model of
\concept{Max Assign Tag}.

\newpage

\subsection{DoubleVec}

A \concept{DoubleVec} is an \concept{Expression Enabled Random Access
  Container} that stores a 3D vector of \comp{double}s.

\subsubsection{Refinement of}
\concept{Expression Enabled Random Access Container} (\cite{rn99046}).

\subsubsection{Associated Types}

No additional types beyond those defined in \concept{Expression
Enabled Random Access Container}, but the requirements for the value
type are strengthened. It must be type \comp{double}.

\subsubsection{Notation}
\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.4\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
  \comp{X} & A type that is a model of \concept{DoubleVec}. \\
  \comp{a} & Object of type \comp{X}. \\
\end{tabularx}

\subsubsection{Valid Expressions}

In addition to the expressions defined in \concept{Expression Enabled
  Random Access Container}, the following expressions must be valid.

\begin{exprlist}
  \expritem{Size}{a.size()}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Return type: & \comp{size\cu type} \\
     Semantics: & Returns the size of the container \comp{a}, that is, 
     the number of elements it contains. \\
     Postcondition: & \comp{3 == a.size() == a.max\cu size()}. \\
     \end{tabularx}}
  \expritem{Maximum size}{a.max\cu size()}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Return type: & \comp{size\cu type} \\
     Semantics: & Returns an upper bound on the container's size. \\
     Postcondition: & \comp{3 == a.size() == a.max\cu size()}. \\
     \end{tabularx}}
\end{exprlist}

\subsubsection{Models}

The \comp{Mesh\cu XYZ::tiny\cu vec<double>} class is a model of
\concept{DoubleVec}.


\newpage

\section{Mesh Concepts}
\label{sec:mesh concepts}

In this section we define the various mesh and mesh-related concepts.

\subsection{Solon Mesh Field}
\label{sec:solon mesh field}

A \concept{Solon Mesh Field} is an \concept{Expression Enabled Forward
  Container} that stores a data field associated with a
\concept{Solon 3D Mesh}.

\subsubsection{Refinement of}
\concept{Expression Enabled Forward Container} (\cite{rn99046}).

\subsubsection{Associated Types}

The requirements for the iterator types are strengthened. The
iterators must iterate only over those parts of the field that are in
the current process. In addition to the types defined in
\concept{Expression Enabled Forward Container}, the following type
is defined.

\begin{typelist}
  \typeitem{Mesh type}{mesh\cu type}{The type of the mesh object with
    respect to which a \concept{Solon Mesh Field} is defined.}
\end{typelist}

\subsubsection{Notation}
\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.4\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
  \comp{X} & A type that is a model of \concept{Solon Mesh Field}. \\
  \comp{a} & Object of type \comp{X}. \\
  \comp{f} & Object of type \comp{mesh\cu type::FieldConstructor}. \\
\end{tabularx}

\subsubsection{Valid Expressions}

In addition to the expressions defined in \concept{Expression Enabled
  Forward Container}, the following expressions must be valid.

\begin{exprlist}
  \expritem{Field Constructor}{X(f)}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Return type: & \comp{X} \\
     \end{tabularx}}
  \expritem{Obtain mesh}{a.get\cu Mesh()}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Return type: & \comp{mesh\cu type\&} \\
     Semantics: & Returns a reference to the mesh object with respect
     to which \comp{a} is defined. \\
     \end{tabularx}}
  \expritem{Obtain field constructor}{a.get\cu FieldConstructor()}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Return type: & \comp{mesh\cu type::FieldConstructor\&} \\
     Postcondition: & The returned reference, when used as an argument 
     to the \concept{Solon Mesh Field} constructor, yields an object defined
     with respect to the same mesh as \comp{a}. \\
     \end{tabularx}}
  \expritem{Beginning of range}{a.begin()}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Return type: & \comp{iterator} if \comp{a} is mutable, otherwise
     \comp{const\cu iterator}. \\
     Semantics: & Returns an iterator pointing to the first element in 
     \comp{a} in the current process. \\
     Postcondition: & \comp{a.begin()} is either dereferenceable or
     past the end. It is past the end if and only if \comp{a.size() == 
       0}. \\
     \end{tabularx}}
  \expritem{End of range}{a.end()}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Return type: & \comp{iterator} if \comp{a} is mutable, otherwise
     \comp{const\cu iterator}. \\
     Semantics: & Returns an iterator pointing to one past the last
     element in \comp{a} in the current process. \\
     Postcondition: & \comp{a.end()} is past the end. The two
     iterators \comp{a.begin()} and \comp{a.end()} if and only if
     \comp{a.size() == 0}. \\
     \end{tabularx}}
  \expritem{Size}{a.size()}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Return type: & \comp{size\cu type} \\
     Semantics: & Returns the size of the field of \comp{a} in the
     current process, that is, the number of elements it contains. \\
     Postcondition: & \comp{0 <= a.size() == a.max\cu size()}. \\
     \end{tabularx}}
  \expritem{Maximum size}{a.max\cu size()}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Return type: & \comp{size\cu type} \\
     Semantics: & Returns an upper bound on the container's size. \\
     Postcondition: & \comp{0 <= a.size() == a.max\cu size()}. \\
     \end{tabularx}}
\end{exprlist}

\subsubsection{Complexity Guarantees}

\begin{complist}
  \compitem{The field constructor is linear in the container's size.}
  \compitem{\comp{get\cu Mesh()} and \comp{get\cu FieldConstructor()}
    are amortized constant time.}
\end{complist}

\subsubsection{Models}

All of the \comp{Mesh\cu XYZ} fields are models of \concept{Solon Mesh
  Field}.

\subsection{Cell Centered Solon Mesh Field}

A \concept{Cell Centered Solon Mesh Field} is a \concept{Solon Mesh
  Field} that contains a value for each cell in the associated mesh.

\subsubsection{Refinement of}
\concept{Solon Mesh Field}.

\subsubsection{Models}

The \comp{Mesh\cu XYZ::cctf<>} class is a model of \concept{Cell
  Centered Solon Mesh Field}.

\bigskip

\subsection{Face Centered Discontinuous Solon Mesh Field}

A \concept{Face Centered Discontinuous Solon Mesh Field} is a
\concept{Solon Mesh Field} that contains a value for each face in the
associated mesh.

\subsubsection{Refinement of}
\concept{Solon Mesh Field}.

\subsubsection{Models}

The \comp{Mesh\cu XYZ::fcdtf<>} class is a model of \concept{Face
  Centered Discontinuous Solon Mesh Field}.

\bigskip

\subsection{Node Centered Solon Mesh Field}

A \concept{Node Centered Solon Mesh Field} is a \concept{Solon Mesh
  Field} that contains a value for each node in the associated mesh.

\subsubsection{Refinement of}
\concept{Solon Mesh Field}.

\subsubsection{Models}

The \comp{Mesh\cu XYZ::nctf<>} class is a model of \concept{Node
  Centered Solon Mesh Field}.

\subsection{Vertex Centered Solon Mesh Field}

A \concept{Vertex Centered Solon Mesh Field} is a \concept{Solon Mesh
  Field} that contains a value for each vertex in the associated mesh.

\subsubsection{Refinement of}
\concept{Solon Mesh Field}.

\subsubsection{Models}

The \comp{Mesh\cu XYZ::vctf<>} class is a model of \concept{Vertex
  Centered Solon Mesh Field}.

\bigskip

\subsection{Boundary Face Solon Mesh Field}

A \concept{Boundary Face Solon Mesh Field} is a \concept{Solon Mesh
  Field} that contains a value for each boundary face in the
associated mesh.

\subsubsection{Refinement of}
\concept{Solon Mesh Field}.

\subsubsection{Models}

The \comp{Mesh\cu XYZ::bftf<>} class is a model of \concept{Boundary
  Face Solon Mesh Field}.


\newpage

\subsection{Solon 3D Mesh}
\label{sec:solon 3d mesh}
A model of \concept{Solon 3D Mesh} is a class that describes a
3D mesh and has nested type definitions for a variety of field types.

\subsubsection{Refinement of}
\concept{Equality Comparable} (~\cite{au99}, page 85).

\subsubsection{Associated Types}

\begin{typelist}
  \typeitem{Size type}{X::size\cu type}{An unsigned integral type that
    can represent the number of cells in the entire mesh.}
  \typeitem{Field constructor type}{X::FieldConstructor}{The argument
    type for constructing a \concept{Solon Mesh Field}.}
  \typeitem{Cell centered template field (cctf)}{template <class T>
    X::cctf<T>}{A model of \concept{Cell Centered Solon Mesh Field}.}
  \typeitem{Face centered discontinuous template field
    (fcdtf)}{template <class T> X::fcdtf<T>}{A model of \concept{Face
      Centered Discontinuous Solon Mesh Field}.}
  \typeitem{Node centered template field (nctf)}{template <class T>
    X::nctf<T>}{A model of \concept{Node Centered Solon Mesh Field}.}
  \typeitem{Vertex centered template field (vctf)}{template <class T>
    X::vctf<T>}{A model of \concept{Vertex Centered Solon Mesh Field}.}
  \typeitem{Boundary face template field (bftf)}{template <class T>
    X::bftf<T>}{A model of \concept{Boundary Face Solon Mesh Field}.}
  \typeitem{Cell centered scalar field}{X::ccsf}{A typedef for
    \comp{X::cctf<double>}.}
  \typeitem{Face centered discontinuous scalar field}{X::fcdsf}{A
    typedef for \comp{X::fcdtf<double>}.}
  \typeitem{Node centered scalar field}{X::ncsf}{A typedef for
    \comp{X::nctf<double>}.}
  \typeitem{Vertex centered scalar field}{X::vcsf}{A typedef for
    \comp{X::vctf<double>}.}
  \typeitem{Boundary face scalar field}{X::bfsf}{A typedef for
    \comp{X::bftf<double>}.}
  \typeitem{Cell centered integer field}{X::ccif}{A typedef for
    \comp{X::cctf<int>}.}
  \typeitem{Face centered discontinuous integer field}{X::fcdif}{A
    typedef for \comp{X::fcdtf<int>}.}
  \typeitem{Node centered integer field}{X::ncif}{A typedef for
    \comp{X::nctf<int>}.}
  \typeitem{Vertex centered integer field}{X::vcif}{A typedef for
    \comp{X::vctf<int>}.}
  \typeitem{Boundary face integer field}{X::bfif}{A typedef for
    \comp{X::bftf<int>}.}
  \typeitem{Cell centered vector scalar field}{X::ccvsf}{A typedef for
    \comp{X::cctf<vec>}, where \comp{vec} is a model of
    \concept{DoubleVec}.}
  \typeitem{Face centered discontinuous vector scalar
    field}{X::fcdvsf}{A typedef for \comp{X::fcdtf<vec>}, where
    \comp{vec} is a model of \concept{DoubleVec}.}
  \typeitem{Node centered vector scalar field}{X::ncvsf}{A typedef for
    \comp{X::nctf<vec>}, where \comp{vec} is a model of
    \concept{DoubleVec}.}
  \typeitem{Vertex centered vector scalar field}{X::vcvsf}{A typedef
    for \comp{X::vctf<vec>}, where \comp{vec} is a model of
    \concept{DoubleVec}.}
  \typeitem{Boundary face vector scalar field}{X::bfvsf}{A typedef
    for \comp{X::bftf<vec>}, where \comp{vec} is a model of
    \concept{DoubleVec}.}
  \typeitem{Assign tag}{X::OpAssign}{A model of \concept{Assign
      Tag}.}
\newpage
  \typeitem{Assign with addition tag}{X::OpAddAssign}{A model of
    \concept{Add Assign Tag}.}
  \typeitem{Assign with subtraction tag}{X::OpSubAssign}{A model
    of \concept{Sub Assign Tag}.}
  \typeitem{Assign with multiplication tag}{X::OpMultAssign}{A
    model of \concept{Mult Assign Tag}.}
  \typeitem{Assign with minimum tag}{X::OpMinAssign}{A model of
    \concept{Min Assign Tag}.}
  \typeitem{Assign with maximum tag}{X::OpMaxAssign}{A model of
    \concept{Max Assign Tag}.}
\end{typelist}

\subsubsection{Notation}
\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.4\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
  \comp{X} & A type that is a model of \concept{Solon 3D Mesh}. \\
  \comp{a,b} & Object of type \comp{X}. \\
  \comp{c} & Object of type \comp{X::ccsf}. \\
  \comp{f} & Object of type \comp{X::fcdsf}. \\
  \comp{fv} & Object of type \comp{X::fcdvsf}. \\
  \comp{v} & Object of type \comp{X::vcsf}. \\
  \comp{n} & Object of type \comp{X::ncsf}. \\
  \comp{ft,ft1,ft2} & Object of type \comp{X::fcdtf<T>}. \\
  \comp{ct} & Object of type \comp{X::cctf<T>}. \\
  \comp{vt} & Object of type \comp{X::vctf<T>}. \\
  \comp{nt} & Object of type \comp{X::nctf<T>}. \\
  \comp{bt} & Object of type \comp{X::bftf<T>}. \\
  \comp{Tag} & A type that is a model of \concept{Scatter/Gather Tag}. \\
  \comp{tag} & Object of type \comp{Tag}. \\
\end{tabularx}

\subsubsection{Definitions}

\begin{deflist}
  \defitem{A {\it cell} of a \concept{Solon 3D Mesh} is the basic mesh
    element. It occupies a fixed region of space; the union of all
    cells as well as their relation to each other makes up the mesh.}
  \defitem{The {\it center} of a cell is the location of its geometric 
    center.}
  \defitem{A {\it face} of a cell is one of the planar areas
    that define its boundary. We sometimes refer to the face {\it
    center}, which is the location of the geometric center of the
    face. If there are two cells sharing the face, then for the
    purposes of defining a face centered discontinuous field we define 
    a separate face center for each cell.}
  \defitem{A {\it node} of a cell is one of the points where three or
    more of its faces touch. If more than one cell has such a point at
    the same geometric location, then those cells share the node.}
  \defitem{A {\it vertex} of a cell is located at the same point as
    one of the cell's nodes. Each cell that shares the node has its
    own separately defined vertex.}
  \defitem{A {\it boundary face} of a \concept{Solon 3D Mesh} is any
    cell face that is located on the boundary of the mesh, i.e. for
    which there is only one cell that is partially defined by it.}
\end{deflist}

\subsubsection{Valid Expressions}

\begin{exprlist}
  \expritem{Equality}{a == b}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Return type: & Convertible to \comp{bool}. \\
     Semantics: & Returns \comp{true} if \comp{\&a == \&b}. Otherwise
     returns \comp{false}. \\
     \end{tabularx}}
  \expritem{Inequality}{a != b}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Return type: & Convertible to \comp{bool}. \\
     Semantics: & Equivalent to \comp{!(a == b)}. \\
     \end{tabularx}}
  \expritem{Number of cells}{a.get\cu ncells()}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Return type: & \comp{size\cu type} \\
     Semantics: & Returns the number of mesh cells in the current
     process. \\
     Postcondition: & \comp{0 <= a.get\cu ncells() <= a.get\cu
       total\cu ncells()}. \\
     \end{tabularx}}
  \expritem{Total number of cells}{a.get\cu total\cu ncells()}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Return type: & \comp{size\cu type} \\
     Semantics: & Returns the total number of mesh cells in all
     processes. \\
     Postcondition: & \comp{0 <= a.get\cu ncells() <= a.get\cu
       total\cu ncells()}. \\
     \end{tabularx}}
  \expritem{X coordinates of cell centers}{a.get\cu xloc(c)}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Type requirements: & \comp{c} is mutable. \\
     Return type: & \comp{void} \\
     Precondition: & \comp{c.get\cu Mesh() == a}. \\
     Semantics: & Each cell value in \comp{c} is assigned the value of
     the x coordinate of that cell's center. \\
     \end{tabularx}}
  \expritem{Y coordinates of cell centers}{a.get\cu yloc(c)}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Type requirements: & \comp{c} is mutable. \\
     Return type: & \comp{void} \\
     Precondition: & \comp{c.get\cu Mesh() == a}. \\
     Semantics: & Each cell value in \comp{c} is assigned the value of
     the y coordinate of that cell's center. \\
     \end{tabularx}}
\newpage
  \expritem{Z coordinates of cell centers}{a.get\cu zloc(c)}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Type requirements: & \comp{c} is mutable. \\
     Return type: & \comp{void} \\
     Precondition: & \comp{c.get\cu Mesh() == a}. \\
     Semantics: & Each cell value in \comp{c} is assigned the value of
     the z coordinate of that cell's center. \\
     \end{tabularx}}
  \expritem{X coordinates of cell faces}{a.get\cu xloc(f)}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Type requirements: & \comp{f} is mutable. \\
     Return type: & \comp{void} \\
     Precondition: & \comp{f.get\cu Mesh() == a}. \\
     Semantics: & Each face value in \comp{f} is assigned the value of
     the x coordinate of that face's center. \\
     \end{tabularx}}
  \expritem{Y coordinates of cell faces}{a.get\cu yloc(f)}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Type requirements: & \comp{f} is mutable. \\
     Return type: & \comp{void} \\
     Precondition: & \comp{f.get\cu Mesh() == a}. \\
     Semantics: & Each face value in \comp{f} is assigned the value of
     the y coordinate of that face's center. \\
     \end{tabularx}}
  \expritem{Z coordinates of cell faces}{a.get\cu zloc(f)}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Type requirements: & \comp{f} is mutable. \\
     Return type: & \comp{void} \\
     Precondition: & \comp{f.get\cu Mesh() == a}. \\
     Semantics: & Each face value in \comp{f} is assigned the value of
     the z coordinate of that face's center. \\
     \end{tabularx}}
  \expritem{Face normals}{a.get\cu face\cu normals(fv)}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Type requirements: & \comp{fv} is mutable. \\
     Return type: & \comp{void} \\
     Precondition: & \comp{fv.get\cu Mesh() == a}. \\
     Semantics: & Each face value in \comp{fv} is assigned the value of
     the outward unit normal on that face. \\
     \end{tabularx}}
  \expritem{Face areas}{a.get\cu face\cu areas(f)}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Type requirements: & \comp{f} is mutable. \\
     Return type: & \comp{void} \\
     Precondition: & \comp{f.get\cu Mesh() == a}. \\
     Semantics: & Each face value in \comp{f} is assigned the value of
     the area of that face. \\
     \end{tabularx}}
\newpage
  \expritem{Face lengths}{a.get\cu face\cu lengths(f)}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Type requirements: & \comp{f} is mutable. \\
     Return type: & \comp{void} \\
     Precondition: & \comp{f.get\cu Mesh() == a}. \\
     Semantics: & Each face value in \comp{f} is assigned the value of
     the length of that face, defined as the volume of the cell in
     which the face is located divided by the face area. \\
     \end{tabularx}}
  \expritem{Cell volumes}{a.get\cu cell\cu volumes(c)}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Type requirements: & \comp{c} is mutable. \\
     Return type: & \comp{void} \\
     Precondition: & \comp{c.get\cu Mesh() == a}. \\
     Semantics: & Each cell value in \comp{c} is assigned the value of
     the volume of the cell. \\
     \end{tabularx}}
  \expritem{Vertex volumes}{a.get\cu vertex\cu volumes(v)}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Type requirements: & \comp{v} is mutable. \\
     Return type: & \comp{void} \\
     Precondition: & \comp{v.get\cu Mesh() == a}. \\
     Semantics: & Each vertex value in \comp{v} is assigned the value of
     the volume of the vertex, defined as the volume of the cell in
     which the vertex is located / 8. \\
     \end{tabularx}}
  \expritem{Node volumes}{a.get\cu node\cu volumes(n)}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Type requirements: & \comp{n} is mutable. \\
     Return type: & \comp{void} \\
     Precondition: & \comp{n.get\cu Mesh() == a}. \\
     Semantics: & Each node value in \comp{n} is assigned the value of
     the volume of the node, defined as the sum of the volumes of the
     vertices associated with that node. \\
     \end{tabularx}}
  \expritem{Cell centered to face centered scatter}
    {X::scatter(ft, ct, tag)}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Type requirements: & \comp{ft} is mutable. \\
     Return type: & \comp{void} \\
     Preconditions: & \comp{ft.get\cu Mesh() == ct.get\cu Mesh()}. \\
       & The operation associated with \comp{tag} is a valid
       expression between \comp{ft}'s value type and \comp{ct}'s value
       type. \\
     Semantics: & For each face value of \comp{ft}, the operation
     associated with \comp{tag} is applied in series to the initial
     face value in \comp{ft} and to each cell value in \comp{ct}
     located in a cell that is adjacent to the face. The result is
     assigned back to the face in \comp{ft}. \\
     \end{tabularx}}
\newpage
  \expritem{Face centered to cell centered scatter}
    {X::scatter(ct, ft, tag)}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Type requirements: & \comp{ct} is mutable. \\
     Return type: & \comp{void} \\
     Preconditions: & \comp{ct.get\cu Mesh() == ft.get\cu Mesh()}. \\
       & The operation associated with \comp{tag} is a valid
       expression between \comp{ct}'s value type and \comp{ft}'s value
       type. \\
     Semantics: & For each cell value of \comp{ct}, the operation
     associated with \comp{tag} is applied in series to the initial
     cell value in \comp{ct} and to each face value in \comp{ft}
     located in the same cell. The result is assigned back to the cell
     in \comp{ct}. \\
     \end{tabularx}}
  \expritem{Vertex centered to face centered scatter}
    {X::scatter(ft, vt, tag)}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Type requirements: & \comp{ft} is mutable. \\
     Return type: & \comp{void} \\
     Preconditions: & \comp{ft.get\cu Mesh() == vt.get\cu Mesh()}. \\
       & The operation associated with \comp{tag} is a valid
       expression between \comp{ft}'s value type and \comp{vt}'s value
       type. \\
     Semantics: & For each face value of \comp{ft}, the operation
     associated with \comp{tag} is applied in series to the initial
     face value in \comp{ft} and to each vertex value in \comp{vt}
     located in the same cell and adjacent to the face. The result is
     assigned back to the face in \comp{ft}. \\
     \end{tabularx}}
  \expritem{Face centered to vertex centered scatter}
    {X::scatter(vt, ft, tag)}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Type requirements: & \comp{vt} is mutable. \\
     Return type: & \comp{void} \\
     Preconditions: & \comp{vt.get\cu Mesh() == ft.get\cu Mesh()}. \\
       & The operation associated with \comp{tag} is a valid
       expression between \comp{vt}'s value type and \comp{ft}'s value
       type. \\
     Semantics: & For each vertex value of \comp{vt}, the operation
     associated with \comp{tag} is applied in series to the initial
     vertex value in \comp{vt} and to each face value in \comp{ft}
     located in the same cell and adjacent to the vertex. The result
     is assigned back to the vertex in \comp{vt}. \\
     \end{tabularx}}
  \expritem{Vertex centered to node centered scatter}
    {X::scatter(nt, vt, tag)}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Type requirements: & \comp{nt} is mutable. \\
     Return type: & \comp{void} \\
     Preconditions: & \comp{nt.get\cu Mesh() == vt.get\cu Mesh()}. \\
       & The operation associated with \comp{tag} is a valid
       expression between \comp{nt}'s value type and \comp{vt}'s value
       type. \\
     Semantics: & For each node value of \comp{nt}, the operation
     associated with \comp{tag} is applied in series to the initial
     node value in \comp{nt} and to each vertex value in \comp{vt}
     adjacent to the node. The result is assigned back to the node in
     \comp{nt}. \\
     \end{tabularx}}
  \expritem{Vertex centered to cell centered scatter}
    {X::scatter(ct, vt, tag)}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Type requirements: & \comp{ct} is mutable. \\
     Return type: & \comp{void} \\
     Preconditions: & \comp{ct.get\cu Mesh() == vt.get\cu Mesh()}. \\
       & The operation associated with \comp{tag} is a valid
       expression between \comp{ct}'s value type and \comp{vt}'s value
       type. \\
     Semantics: & For each cell value of \comp{ct}, the operation
     associated with \comp{tag} is applied in series to the initial
     cell value in \comp{ct} and to each vertex value in \comp{vt} in
     the same cell. The result is assigned back to the cell in
     \comp{ct}. \\
     \end{tabularx}}
  \expritem{Cell centered to face centered gather}
    {X::gather(ft, ct, tag)}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Type requirements: & \comp{ft} is mutable. \\
     Return type: & \comp{void} \\
     Preconditions: & \comp{ft.get\cu Mesh() == ct.get\cu Mesh()}. \\
       & The operation associated with \comp{tag} is a valid
       expression between \comp{ft}'s value type and \comp{ct}'s value
       type. \\
     Semantics: & For each face value of \comp{ft}, the operation
     associated with \comp{tag} is applied between the initial face
     value in \comp{ft} and to the cell value in \comp{ct} in the same
     cell. The result is assigned back to the face in \comp{ft}. \\
     \end{tabularx}}
  \expritem{Face centered to boundary face gather}
    {X::gather(bt, ft, tag)}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Type requirements: & \comp{bt} is mutable. \\
     Return type: & \comp{void} \\
     Preconditions: & \comp{bt.get\cu Mesh() == ft.get\cu Mesh()}. \\
       & The operation associated with \comp{tag} is a valid
       expression between \comp{bt}'s value type and \comp{ft}'s value
       type. \\
     Semantics: & For each boundary value of \comp{bt}, the operation
     associated with \comp{tag} is applied between the initial
     boundary value in \comp{bt} and to the face value in \comp{ft}
     adjacent to it. The result is assigned back to the boundary in
     \comp{bt}. \\
     \end{tabularx}}
  \expritem{Boundary face to face centered gather}
    {X::gather(ft, bt, tag)}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Type requirements: & \comp{ft} is mutable. \\
     Return type: & \comp{void} \\
     Preconditions: & \comp{ft.get\cu Mesh() == bt.get\cu Mesh()}. \\
       & The operation associated with \comp{tag} is a valid
       expression between \comp{ft}'s value type and \comp{bt}'s value
       type. \\
     Semantics: & For each face value of \comp{ft}, the operation
     associated with \comp{tag} is applied between the initial face
     value in \comp{ft} and to the boundary value in \comp{bt}
     adjacent to it. The result is assigned back to the face in
     \comp{ft}. \\
     \end{tabularx}}
  \expritem{Node centered to vertex centered gather}
    {X::gather(vt, nt, tag)}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Type requirements: & \comp{vt} is mutable. \\
     Return type: & \comp{void} \\
     Preconditions: & \comp{vt.get\cu Mesh() == nt.get\cu Mesh()}. \\
       & The operation associated with \comp{tag} is a valid
       expression between \comp{vt}'s value type and \comp{nt}'s value
       type. \\
     Semantics: & For each vertex value of \comp{vt}, the operation
     associated with \comp{tag} is applied between the initial vertex
     value in \comp{vt} and to the node value in \comp{nt} adjacent to
     it. The result is assigned back to the vertex in \comp{vt}. \\
     \end{tabularx}}
  \expritem{Cell centered to vertex centered gather}
    {X::gather(vt, ct, tag)}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Type requirements: & \comp{vt} is mutable. \\
     Return type: & \comp{void} \\
     Preconditions: & \comp{vt.get\cu Mesh() == ct.get\cu Mesh()}. \\
       & The operation associated with \comp{tag} is a valid
       expression between \comp{vt}'s value type and \comp{ct}'s value
       type. \\
     Semantics: & For each vertex value of \comp{vt}, the operation
     associated with \comp{tag} is applied between the initial vertex
     value in \comp{vt} and to the cell value in \comp{ct} in the same
     cell. The result is assigned back to the vertex in \comp{vt}. \\
     \end{tabularx}}
  \expritem{Face swaps}
    {X::swap\cu faces(ft1, ft2)}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Type requirements: & \comp{ft1} is mutable. \\
     Return type: & \comp{void} \\
     Preconditions: & \comp{ft1.get\cu Mesh() == ft2.get\cu
       Mesh()}. \\
     Semantics: & For each pair of face values in \comp{ft2}, the
     order of the values is reversed and assigned to the corresponding
     pair in \comp{ft1}. At boundaries (where there are no face pairs)
     the single face value should be assigned \comp{0}. \\
     \end{tabularx}}
  \expritem{Cell centered sum}
    {X::sum(ct)}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Return type: & The value type of \comp{ct}. \\
     Semantics: & The value returned is the sum of all values
     contained in \comp{ct} in all processes. \\
     \end{tabularx}}
  \expritem{Face centered sum}
    {X::sum(ft)}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Return type: & The value type of \comp{ft}. \\
     Semantics: & The value returned is the sum of all values
     contained in \comp{ft} in all processes. \\
     \end{tabularx}}
\newpage
  \expritem{Node centered sum}
    {X::sum(nt)}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Return type: & The value type of \comp{nt}. \\
     Semantics: & The value returned is the sum of all values
     contained in \comp{nt} in all processes. \\
     \end{tabularx}}
  \expritem{Vertex centered sum}
    {X::sum(vt)}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Return type: & The value type of \comp{vt}. \\
     Semantics: & The value returned is the sum of all values
     contained in \comp{vt} in all processes. \\
     \end{tabularx}}
  \expritem{Boundary face sum}
    {X::sum(bt)}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Return type: & The value type of \comp{bt}. \\
     Semantics: & The value returned is the sum of all values
     contained in \comp{bt} in all processes. \\
     \end{tabularx}}
  \expritem{Cell centered minimum}
    {X::min(ct)}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Return type: & The value type of \comp{ct}. \\
     Semantics: & The value returned is the minimum of all values
     contained in \comp{ct} in all processes. \\
     \end{tabularx}}
  \expritem{Face centered minimum}
    {X::min(ft)}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Return type: & The value type of \comp{ft}. \\
     Semantics: & The value returned is the minimum of all values
     contained in \comp{ft} in all processes. \\
     \end{tabularx}}
  \expritem{Node centered minimum}
    {X::min(nt)}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Return type: & The value type of \comp{nt}. \\
     Semantics: & The value returned is the minimum of all values
     contained in \comp{nt} in all processes. \\
     \end{tabularx}}
  \expritem{Vertex centered minimum}
    {X::min(vt)}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Return type: & The value type of \comp{vt}. \\
     Semantics: & The value returned is the minimum of all values
     contained in \comp{vt} in all processes. \\
     \end{tabularx}}
  \expritem{Boundary face minimum}
    {X::min(bt)}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Return type: & The value type of \comp{bt}. \\
     Semantics: & The value returned is the minimum of all values
     contained in \comp{bt} in all processes. \\
     \end{tabularx}}
\newpage
  \expritem{Cell centered maximum}
    {X::max(ct)}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Return type: & The value type of \comp{ct}. \\
     Semantics: & The value returned is the maximum of all values
     contained in \comp{ct} in all processes. \\
     \end{tabularx}}
  \expritem{Face centered maximum}
    {X::max(ft)}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Return type: & The value type of \comp{ft}. \\
     Semantics: & The value returned is the maximum of all values
     contained in \comp{ft} in all processes. \\
     \end{tabularx}}
  \expritem{Node centered maximum}
    {X::max(nt)}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Return type: & The value type of \comp{nt}. \\
     Semantics: & The value returned is the maximum of all values
     contained in \comp{nt} in all processes. \\
     \end{tabularx}}
  \expritem{Vertex centered maximum}
    {X::max(vt)}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Return type: & The value type of \comp{vt}. \\
     Semantics: & The value returned is the maximum of all values
     contained in \comp{vt} in all processes. \\
     \end{tabularx}}
  \expritem{Boundary face maximum}
    {X::max(bt)}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Return type: & The value type of \comp{bt}. \\
     Semantics: & The value returned is the maximum of all values
     contained in \comp{bt} in all processes. \\
     \end{tabularx}}
\end{exprlist}

\subsubsection{Complexity Guarantees}

\begin{complist}
  \compitem{The comparison operations are amortized constant time.}
  \compitem{All of the other operations defined above are linear in
    the number of cells in the mesh.}
\end{complist}

\subsubsection{Models}

The \comp{Mesh\cu XYZ} class is a model of \concept{Solon 3D Mesh}.

\newpage

\subsection{Solon 3D Orthogonal Cartesian Mesh}
\label{sec:solon 3d orth cart mesh}

A \concept{Solon 3D Orthogonal Cartesian Mesh} is a \concept{Solon 3D
  Mesh} that describes an orthogonal Cartesian mesh. The mesh is
required to have a fixed number of orthogonal hexahedral cells in any
particular direction.

\subsubsection{Refinement of}
\concept{Solon 3D Mesh}.

\subsubsection{Associated Types}

There are no additional types beyond those defined in \concept{Solon
  3D Mesh}.

\subsubsection{Notation}
\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.4\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
  \comp{X} & A type that is a model of \concept{Solon 3D Orthogonal
    Cartesian Mesh}. \\
  \comp{a} & Object of type \comp{X}. \\
  \comp{c} & Object of type \comp{X::ccsf}. \\
\end{tabularx}

\subsubsection{Valid Expressions}

\begin{exprlist}
  \expritem{Number of cells along x-axis}{a.get\cu ncx()}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Return type: & \comp{size\cu type} \\
     Semantics: & Returns the number of mesh cells along the x-axis in
     the full mesh. \\
     Postcondition: & \comp{0 <= a.get\cu ncx() <= a.get\cu total\cu
       ncells()}. \\
     \end{tabularx}}
  \expritem{Number of cells along y-axis}{a.get\cu ncy()}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Return type: & \comp{size\cu type} \\
     Semantics: & Returns the number of mesh cells along the y-axis in
     the full mesh. \\
     Postcondition: & \comp{0 <= a.get\cu ncy() <= a.get\cu total\cu
       ncells()}. \\
     \end{tabularx}}
  \expritem{Number of cells along z-axis}{a.get\cu ncz()}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Return type: & \comp{size\cu type} \\
     Semantics: & Returns the number of mesh cells along the z-axis in
     the full mesh. \\
     Postcondition: & \comp{0 <= a.get\cu ncz() <= a.get\cu total\cu
       ncells()}. \\
     \end{tabularx}}
\newpage
  \expritem{Total number of cells}{a.get\cu total\cu ncells()}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Return type: & \comp{size\cu type} \\
     Semantics: & Returns the total number of mesh cells in all
     processes. Equivalent to \comp{a.get\cu ncx()*a.get\cu
       ncy()*a.get\cu ncz()}. \\
     Postcondition: & \comp{0 <= a.get\cu ncells() <= a.get\cu
       total\cu ncells()}. \\
     \end{tabularx}}
  \expritem{$\Delta$x}{a.get\cu dx(c)}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Type requirements: & \comp{c} is mutable. \\
     Return type: & \comp{void} \\
     Precondition: & \comp{c.get\cu Mesh() == a}. \\
     Semantics: & Each cell value in \comp{c} is assigned the value of
     $\Delta$x for that cell. \\
     \end{tabularx}}
  \expritem{$\Delta$y}{a.get\cu dy(c)}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Type requirements: & \comp{c} is mutable. \\
     Return type: & \comp{void} \\
     Precondition: & \comp{c.get\cu Mesh() == a}. \\
     Semantics: & Each cell value in \comp{c} is assigned the value of
     $\Delta$y for that cell. \\
     \end{tabularx}}
  \expritem{$\Delta$z}{a.get\cu dz(c)}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Type requirements: & \comp{c} is mutable. \\
     Return type: & \comp{void} \\
     Precondition: & \comp{c.get\cu Mesh() == a}. \\
     Semantics: & Each cell value in \comp{c} is assigned the value of
     $\Delta$z for that cell. \\
     \end{tabularx}}
\end{exprlist}

\subsubsection{Complexity Guarantees}

\begin{complist}
  \compitem{The operations defined above are linear in the number of
    cells in the mesh.}
\end{complist}

\subsubsection{Models}

The \comp{Mesh\cu XYZ} class is a model of \concept{Solon 3D
  Orthogonal Cartesian Mesh}.


\bibliographystyle{rnote}
\bibliography{draco}

\closing
\end{document}

%%---------------------------------------------------------------------------%%
%% end of MTConcept.tex
%%---------------------------------------------------------------------------%%
